<!DOCTYPE html>
<html lang="en">
<!-- NAME: Tre Williams-->
<!-- PROGRAM PURPOSE: This is my PVCC index file. it will have links to all my coursework-->

<head>
    <title>Chapter 3: Operating Systems</title>
<style>
    a{text-decoration: none;}
    a:link{color: #4727d4;}
    a:visited{color: black;}
    a:hover{color: #FFFFFF;}
    a:active{color: #000000 ;}
</style>
<body style="background-color: #60066e; font-family: Arial, Helvetica, sans-serif; background-image: url(digital.png);">
<table border="2" style="width: 50%; color: #60066e; background-color: #e0c0ff; margin: auto;">
</head>
<tr>
    <td><a href="ch3opsys.html">HOME</a></td>
    <td><a href="https://www.pvcc.edu/">PVCC</a></td>
    <td><a href="https://www.w3schools.com/">W3SCHOOLS</a></td>
    <td><a href="contactus.html">CONTACT US</a></td>
</tr>
<tr><td colspan="4" ><ul>
    <h1> Chapter 5: Networking & The Internet</h1>
<table>
    <tr>
        <td>Phases of computer program development:</td>
    </tr>
    <tr>
        <td>Phase 1:</td>
        <td>Understand the problem</td>
    </tr>
    <tr>
        <td>Phase 2:</td>
        <td>Design an algorithm to solve the problem</td>
    </tr>
    <tr>
        <td>Phase 3:</td>
        <td>Write the prgram in appropriate language based on algorithm</td>
    </tr>
    <tr>
        <td>Phase 4:</td>
        <td>Enter the program and save</td>
    </tr>
    <tr>
        <td>Phase 5:</td>
        <td>Execute the program</td>
    </tr>
    <tr>
        <td>Phase 6:</td>
        <td>Test the program, find errors and debug, then retest</td>
    </tr>
    <tr>
        <td>Phase 7:</td>
        <td>Document and evaluate the program</td>
    </tr>
    <tr>
        <td>Programming structures:</td>
    </tr>
    <tr>
        <td>Sequential structure:</td>
        <td>Top-down execution</td>
    </tr>
    <tr>
        <td>Decision structures:</td>
        <td>if/then/else</td>
    </tr>
    <tr>
        <td>Iterative (looping):</td>
    </tr>
    <tr>
        <td></td>
        <td>While loop: continue looping as long something is true</td>
    </tr>
    <tr>
        <td></td>
        <td>Repeat/until loop: continue looping until something is true</td>
    </tr>
    <tr>    
        <td></td>
        <td>for loop: loop a given number of times</td>
    </tr>
    <tr>
        <td>Recursive structures</td>
        <td>Repeat a set of instructions as a subtask of itself</td>
    </tr>    
    <tr>
        <td></td>
        <td>Repetition continues until: degenerative case, which is a termination condition, is met</td>
    </tr>
    <tr>
        <td>Two classic programming/database problems</td>
    </tr>
    <tr>
        <td>sorting: Descending order/Ascending order</td>
        <td>a distributed application architecture that partitions tasks or workloads between peers.</td>
    </tr>
    <tr>
        <td></td>
        <td>sorting numbers</td>
    </tr>
    <tr>
        <td></td>
        <td>Sorting strings (in accordance with ASCII values)</td>
    </tr>
    <tr>
        <td>Searching:</td>
        <td>Find specific data that meet a certain criteria</td>
    </tr>
    <tr>
        <td>In Database:</td>
    </tr>
    <tr>
        <td>Fliters:</td>
        <td>temporary search</td>
    </tr>
    <tr>
        <td>Queries:</td>
        <td>search criteria are saved so  they don't have to be recreated</td>
    </tr>
    <tr>
        <td>Two popular search techniques:</td>
        <td>Sequential search: search from top to bottom or bottom to top, one item at a time</td>
    </tr>
    <tr>
        <td></td>
        <td>Binary search: only works if data is stored first, start in middle, then go to half of that, etc.</td>
    </tr>
    <tr>
        <td>Two classic program goals:</td>
    </tr>
    <tr>
        <td>Efficiency:</td>
        <td>Program takes minimal time and/or resources</td>
    </tr>
    <tr>
        <td>Correctness:</td>
        <td>Program runs in expected ways and works for all expected conditions</td>
    </tr>
    <tr>
        <td>Software testing and verification</td>
    </tr>
    <tr>
        <td>Kinds of tests:</td>
    </tr>
    <tr>
        <td>Acceptance testing:</td>
        <td>Verifying whether the whole system works as intended</td>
    <tr>
        <td>integration testing</td>
        <td>Ensuring that software components or functions operate together</td>
    </tr>
    <tr>
        <td>Unit testing:</td>
        <td>Validating that each software unit runs as expected.</td>
    </tr>
    <tr>
        <td>Functional testing:</td>
        <td>Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common  way to verify functions</td>
    </tr>
    <tr>
        <td>Perfomance testing:</td>
        <td>Testing how the software runs  under different workloads</td>
    </tr>
    <tr>
        <td>Regression testing:</td>
        <td>Checking whether new features break or degrade functionality</td>
    </tr>
    <tr>
        <td>Stress testing:</td>
        <td>Testing how much strain the system can take before it fails.</td>
    </tr>
    <tr>
        <td>Usability testing:</td>
        <td>Validating how well a  customer can use a system or web application to complete a task</td>
    
    <tr>
        <td>Software testing is done to detect:</td>
    </tr>
    <tr>
        <td></td>
        <td>Architectural flaws</td>
    </tr>
    <tr>
        <td></td>
        <td>Poor design decisions</td>
    </tr>
    <tr>
        <td></td>
        <td>Invalid or incorrect functionality</td>
    </tr>
    <tr>
        <td></td>
        <td>Security vulnerabilities</td>
    </tr>
    <tr>
        <td></td>
        <td>Scalability issues</td>
    </tr>
    <tr>
        <td>Testing best practices:</td>
    </tr>
    <tr>
        <td>Continous testing:</td>
        <td>This type of software testing relies on test automation that is integrated with the deployment process. It enables software to be validated in realistic test environments earlier in the process, which improves design and reduces risks.</td>
    </tr>
    <tr>
        <td>Configuration management:</td>
        <td>gain access to assets such as code, requirements, design documents, models, test scripts and test results.</td>
    </tr>
    <tr>
        <td>Service virtualiztion:</td>
        <td>simulates the services and systems that are missing or not yet completed, enabling teams to reduce dependencies and test sooner.</td>
    </tr>
    <tr>
        <td>Defect or bug tracking:</td>
        <td>Automated tools allow teams to track defects, measure their scope and impact, and uncover related issues.</td>
    </tr>
    <tr>
        <td>Metrics and reporting:</td>
        <td>Teams quickly see the overall health of a project and can monitor relationships between test, development and other project elements.</td>
    </tr>
</table>  
</td></tr>
</body>
</html>